#pragma once

#include <cstddef>
#include <optional>
#include <set>
#include <string_view>
#include <unordered_map>
#include <vector>

#include "parser.h"
#include "timeutil.h"

namespace event_system {

enum ComputerClubError {
    err_client_already_in,  // - caused when `in_client_came_in` event is called
                            // on the user, who has not leave yet
    err_client_came_early,  // - caused when `in_client_came_in` event is called
                            // in the non-working hours
    err_client_table_taken, // - caused when `in_client_sit` is called, but a
                            // table is already being used by other client
    err_client_unknown, // - caused when `in_client_sit` or `in_client_left` are
                        // called on wrong client
    err_client_awaits_nothing, // - caused when `in_client_awaiting` is called,
                               // but there are some at least one table is
                               // available
};

enum EventType {
    // events read by the program from the file:
    in_client_came_in  = 1,
    in_client_sit      = 2,
    in_client_awaiting = 3,
    in_client_left     = 4,
    // events generated by the program:
    out_client_left    = 11,
    out_client_sit     = 12,
    out_error          = 13,
};

class Table {
    std::size_t id; // should never be equal to 0

    bool is_occupied { false };

    std::size_t revenue { 0 };
    std::size_t total_mins { 0 };

    std::optional<timeutil::TimePoint> last_sit {};

public:
    explicit Table(std::size_t id);

    [[nodiscard]] constexpr auto occupied() const -> bool;

    auto sit(timeutil::TimePoint time) -> void;

    auto leave(timeutil::TimePoint time, std::size_t hour_cost) -> void;

    auto write_stats_to_file(FILE *f) const -> int;

    [[nodiscard]] constexpr auto get_id() const -> std::size_t;
};

struct Event {
    timeutil::TimePoint              time;
    // NOTE: Events that have type `out_error` but have no error
    // code are the ones that are not in the trial specification and
    // assumed to be critical errors
    EventType                        type;
    std::string_view                 client_name;
    std::optional<std::size_t>       table_id;
    std::optional<ComputerClubError> error_code;

    auto operator<(const Event &other) const -> bool;

    // FORMAT: [TIME POINT] [SPACE] [EVENT_ID] [SPACE] [CLIENT] [SPACE] \
    // ([TABLE_ID])
    auto from_parser(BasicParser &parser) -> bool;
};

struct Config {
    std::size_t            tables_count;
    timeutil::TimeInterval work_hours;
    std::size_t            hour_cost;

    // FORMAT: [TABLES COUNT] [NEW LINE]
    //         [TIME INTERVAL] [NEW LINE]
    //         [HOUR COST]
    auto from_parser(BasicParser &parser) -> bool;
};

enum ClientState {
    client_state_inside,
    client_state_awaits,
    client_state_sits,
};

struct Client {
    std::optional<std::size_t> table_id {};
    ClientState                state { client_state_inside };
};

class EventSystem {
    std::unordered_map<std::string_view, Client> clients;
    std::vector<Table>                           tables;
    timeutil::TimeInterval                       work_hours;
    std::size_t                                  hour_cost;

public:
    EventSystem(std::size_t tables_count, timeutil::TimeInterval work_hours,
        std::size_t hour_cost);

private:
    auto is_queue_full() const -> bool;

    auto sit_client_table(std::string_view client_name, std::size_t id,
        timeutil::TimePoint time) -> void;

    auto handle_client_came_in(
        const Event &event, std::optional<Event> &out_event) -> void;

    auto handle_client_sit(const Event &event, std::optional<Event> &out_event)
        -> void;

    auto handle_client_awaiting(
        const Event &event, std::optional<Event> &out_event) -> void;

    auto handle_client_left(const Event &event, std::optional<Event> &out_event)
        -> void;

    auto handle_unexpected(std::optional<Event> &out_event) -> void;

public:
    // to make it a bit more efficent, the resulting value will be stored in the
    // same event it got
    auto handle_event(Event &event, std::optional<Event> &out_event) -> void;

    auto kick_everyone_out(std::set<Event> &events) -> void;

    auto write_tables_stats(FILE *f) -> int;
};

} // namespace event_system;
